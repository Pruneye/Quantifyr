{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantifyr","text":"<p>A hybrid classical-quantum molecular machine learning platform. Transform molecules into quantum-ready representations with interactive visualizations and robust ML pipelines.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from data_utils import parse_smiles, mol_to_graph, create_molecular_dataframe\nfrom viz import draw_molecule_2d, create_3d_conformer_plot\n\n# Parse molecule from SMILES\nmol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")  # caffeine\n\n# Create visualizations\nimg = draw_molecule_2d(mol)\nfig = create_3d_conformer_plot(mol)\n\n# Convert to ML-ready graph\ngraph = mol_to_graph(mol)  # PyTorch Geometric format\n\n# Batch analysis with properties\ndf = create_molecular_dataframe([\"CCO\", \"c1ccccc1\", \"CC(=O)OC1=CC=CC=C1C(=O)O\"])\n</code></pre>"},{"location":"#core-modules","title":"Core Modules","text":""},{"location":"#data_utils","title":"data_utils","text":"<ul> <li><code>parse_smiles()</code> - SMILES string parsing and validation</li> <li><code>mol_to_graph()</code> - Convert to PyTorch Geometric graphs</li> <li><code>create_molecular_dataframe()</code> - Batch property analysis</li> <li><code>compute_molecular_descriptors()</code> - Calculate MW, LogP, TPSA, etc.</li> </ul>"},{"location":"#viz","title":"viz","text":"<ul> <li><code>draw_molecule_2d()</code> - Generate 2D molecular structures</li> <li><code>create_3d_conformer_plot()</code> - Interactive 3D molecular models</li> <li><code>plot_molecular_properties()</code> - Property correlation analysis</li> <li><code>create_molecular_dashboard()</code> - Comprehensive analysis dashboards</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Data Processing - Complete molecular data processing guide</li> <li>Visualization - Interactive molecular visualizations</li> <li>API Reference - Detailed function documentation</li> </ul>"},{"location":"#development-status","title":"Development Status","text":"<ul> <li>Stage 1: Molecular data processing and visualization (Complete)</li> <li>Stage 2: Classical autoencoders (Planned)</li> <li>Stage 3: Quantum autoencoders (Planned)</li> <li>Stage 4: Hybrid GNN-Quantum pipelines (Planned)</li> </ul>"},{"location":"tutorials/api-reference/","title":"API Reference","text":""},{"location":"tutorials/api-reference/#data_utils-module","title":"data_utils Module","text":""},{"location":"tutorials/api-reference/#molecular-parsing","title":"Molecular Parsing","text":""},{"location":"tutorials/api-reference/#parse_smilessmiles-str-config-optionalmoleculeconfig-none-mol","title":"<code>parse_smiles(smiles: str, config: Optional[MoleculeConfig] = None) -&gt; Mol</code>","text":"<p>Parse SMILES string into RDKit molecule object with comprehensive error handling.</p> <p>Parameters:</p> <ul> <li><code>smiles</code> (str): SMILES string representation</li> <li><code>config</code> (MoleculeConfig, optional): Configuration for processing settings</li> </ul> <p>Returns: RDKit Mol object</p> <p>Raises: ValueError if SMILES string is invalid</p> <p>Example:</p> <pre><code>from data_utils import parse_smiles, MoleculeConfig\n\n# Basic parsing\nmol = parse_smiles(\"CCO\")\n\n# Custom configuration\nconfig = MoleculeConfig(add_hydrogens=True, max_atoms=100)\nmol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\", config)\n</code></pre>"},{"location":"tutorials/api-reference/#moleculeconfig","title":"<code>MoleculeConfig</code>","text":"<p>Configuration class for molecular processing options.</p> <p>Attributes:</p> <ul> <li><code>add_hydrogens</code> (bool): Whether to add explicit hydrogens (default: False)</li> <li><code>sanitize</code> (bool): Whether to sanitize molecules (default: True)</li> <li><code>max_atoms</code> (int): Maximum number of atoms allowed (default: 200)</li> </ul>"},{"location":"tutorials/api-reference/#feature-extraction","title":"Feature Extraction","text":""},{"location":"tutorials/api-reference/#extract_atom_featuresmol-mol-listlistfloat","title":"<code>extract_atom_features(mol: Mol) -&gt; List[List[float]]</code>","text":"<p>Extract atomic features for each atom in the molecule.</p> <p>Features extracted:</p> <ul> <li>Atomic number</li> <li>Degree (number of bonds)</li> <li>Formal charge</li> <li>Hybridization type (SP, SP2, SP3, etc.)</li> <li>Aromaticity (boolean)</li> <li>Number of implicit hydrogens</li> </ul> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> </ul> <p>Returns: List of feature vectors, one per atom</p> <p>Example:</p> <pre><code>mol = parse_smiles(\"CCO\")\natom_features = extract_atom_features(mol)\nprint(f\"Atom features shape: {len(atom_features)} atoms x {len(atom_features[0])} features\")\n</code></pre>"},{"location":"tutorials/api-reference/#extract_bond_featuresmol-mol-listlistfloat","title":"<code>extract_bond_features(mol: Mol) -&gt; List[List[float]]</code>","text":"<p>Extract bond features for each bond in the molecule.</p> <p>Features extracted:</p> <ul> <li>Bond type (single=1, double=2, triple=3, aromatic=1.5)</li> <li>Conjugation status (boolean)</li> <li>Ring membership (boolean)</li> </ul> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> </ul> <p>Returns: List of feature vectors, one per bond</p>"},{"location":"tutorials/api-reference/#graph-construction","title":"Graph Construction","text":""},{"location":"tutorials/api-reference/#mol_to_graphmol-mol-include_features-bool-true-data","title":"<code>mol_to_graph(mol: Mol, include_features: bool = True) -&gt; Data</code>","text":"<p>Convert RDKit molecule to PyTorch Geometric graph representation.</p> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> <li><code>include_features</code> (bool): Whether to include node/edge features (default: True)</li> </ul> <p>Returns: PyTorch Geometric Data object with:</p> <ul> <li><code>x</code>: Node features (if include_features=True)</li> <li><code>edge_index</code>: Edge connectivity in COO format</li> <li><code>edge_attr</code>: Edge features (if include_features=True)</li> </ul> <p>Example:</p> <pre><code>mol = parse_smiles(\"CCO\")\ngraph = mol_to_graph(mol)\n\nprint(f\"Nodes: {graph.num_nodes}\")\nprint(f\"Edges: {graph.num_edges}\")\nprint(f\"Node features: {graph.x.shape}\")\nprint(f\"Edge features: {graph.edge_attr.shape}\")\n</code></pre>"},{"location":"tutorials/api-reference/#property-calculation","title":"Property Calculation","text":""},{"location":"tutorials/api-reference/#compute_molecular_descriptorsmol-mol-dictstr-float","title":"<code>compute_molecular_descriptors(mol: Mol) -&gt; Dict[str, float]</code>","text":"<p>Calculate comprehensive molecular properties and descriptors.</p> <p>Properties calculated:</p> <ul> <li>MW: Molecular weight (Da)</li> <li>LogP: Partition coefficient (lipophilicity)</li> <li>TPSA: Topological polar surface area (\u0172)</li> <li>NumRotatableBonds: Number of rotatable bonds</li> <li>NumHBD: Hydrogen bond donors</li> <li>NumHBA: Hydrogen bond acceptors</li> <li>NumRings: Number of rings</li> </ul> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> </ul> <p>Returns: Dictionary mapping property names to values</p> <p>Example:</p> <pre><code>mol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")  # caffeine\nprops = compute_molecular_descriptors(mol)\n\nprint(f\"Molecular Weight: {props['MW']:.2f} Da\")\nprint(f\"LogP: {props['LogP']:.2f}\")\nprint(f\"TPSA: {props['TPSA']:.2f} \u0172\")\n</code></pre>"},{"location":"tutorials/api-reference/#batch-processing","title":"Batch Processing","text":""},{"location":"tutorials/api-reference/#load_molecule_datasetsmiles_list-liststr-labels-optionallist-none-listmol","title":"<code>load_molecule_dataset(smiles_list: List[str], labels: Optional[List] = None) -&gt; List[Mol]</code>","text":"<p>Load and validate multiple SMILES strings into molecule objects.</p> <p>Parameters:</p> <ul> <li><code>smiles_list</code> (List[str]): List of SMILES strings</li> <li><code>labels</code> (List, optional): Optional labels/targets for molecules</li> </ul> <p>Returns: List of RDKit Mol objects (None for invalid SMILES)</p>"},{"location":"tutorials/api-reference/#create_molecular_dataframesmiles_list-liststr-pddataframe","title":"<code>create_molecular_dataframe(smiles_list: List[str]) -&gt; pd.DataFrame</code>","text":"<p>Create comprehensive molecular analysis DataFrame with computed properties.</p> <p>Parameters:</p> <ul> <li><code>smiles_list</code> (List[str]): List of SMILES strings</li> </ul> <p>Returns: Pandas DataFrame with columns:</p> <ul> <li><code>SMILES</code>: Original SMILES string</li> <li><code>Valid</code>: Whether parsing succeeded</li> <li><code>MW</code>, <code>LogP</code>, <code>TPSA</code>, etc.: Computed molecular properties</li> </ul> <p>Example:</p> <pre><code>smiles = [\"CCO\", \"c1ccccc1\", \"INVALID\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]\ndf = create_molecular_dataframe(smiles)\n\n# Filter valid molecules\nvalid_df = df[df['Valid']]\nprint(f\"Valid molecules: {len(valid_df)}/{len(df)}\")\nprint(valid_df[['SMILES', 'MW', 'LogP', 'TPSA']].head())\n</code></pre>"},{"location":"tutorials/api-reference/#viz-module","title":"viz Module","text":""},{"location":"tutorials/api-reference/#2d-visualization","title":"2D Visualization","text":""},{"location":"tutorials/api-reference/#draw_molecule_2dmol-mol-width-int-300-height-int-300-kwargs-pilimage","title":"<code>draw_molecule_2d(mol: Mol, width: int = 300, height: int = 300, **kwargs) -&gt; PIL.Image</code>","text":"<p>Generate 2D molecular structure diagrams.</p> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> <li><code>width</code> (int): Image width in pixels (default: 300)</li> <li><code>height</code> (int): Image height in pixels (default: 300)</li> <li><code>**kwargs</code>: Additional RDKit drawing options</li> </ul> <p>Returns: PIL Image object</p> <p>Example:</p> <pre><code>from data_utils import parse_smiles\nfrom viz import draw_molecule_2d\n\nmol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\nimg = draw_molecule_2d(mol, width=400, height=300)\nimg.save(\"caffeine_2d.png\")\nimg.show()\n</code></pre>"},{"location":"tutorials/api-reference/#3d-visualization","title":"3D Visualization","text":""},{"location":"tutorials/api-reference/#create_3d_conformer_plotmol-mol-kwargs-plotlygraph_objectsfigure","title":"<code>create_3d_conformer_plot(mol: Mol, **kwargs) -&gt; plotly.graph_objects.Figure</code>","text":"<p>Create interactive 3D molecular conformer visualization.</p> <p>Features:</p> <ul> <li>Rotatable 3D structure</li> <li>Atom labels and element-based coloring</li> <li>Bond representations</li> <li>Interactive hover information</li> </ul> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> <li><code>**kwargs</code>: Additional plotting options</li> </ul> <p>Returns: Plotly Figure object</p> <p>Example:</p> <pre><code>mol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\nfig = create_3d_conformer_plot(mol)\nfig.show()  # Opens in browser\nfig.write_html(\"caffeine_3d.html\")\n</code></pre>"},{"location":"tutorials/api-reference/#property-analysis","title":"Property Analysis","text":""},{"location":"tutorials/api-reference/#plot_molecular_propertiesdf-pddataframe-kwargs-plotlygraph_objectsfigure","title":"<code>plot_molecular_properties(df: pd.DataFrame, **kwargs) -&gt; plotly.graph_objects.Figure</code>","text":"<p>Create interactive scatter matrix of molecular properties.</p> <p>Features:</p> <ul> <li>Scatter plots for all property combinations</li> <li>Hover information showing SMILES and values</li> <li>Configurable markers and colors</li> </ul> <p>Parameters:</p> <ul> <li><code>df</code> (pd.DataFrame): Molecular DataFrame from <code>create_molecular_dataframe()</code></li> <li><code>**kwargs</code>: Additional plotting options</li> </ul> <p>Returns: Plotly Figure object</p> <p>Example:</p> <pre><code>from data_utils import create_molecular_dataframe\nfrom viz import plot_molecular_properties\n\nsmiles_list = [\"CCO\", \"c1ccccc1\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]\ndf = create_molecular_dataframe(smiles_list)\nfig = plot_molecular_properties(df)\nfig.show()\n</code></pre>"},{"location":"tutorials/api-reference/#plot_property_distributiondf-pddataframe-properties-liststr-kwargs-plotlygraph_objectsfigure","title":"<code>plot_property_distribution(df: pd.DataFrame, properties: List[str], **kwargs) -&gt; plotly.graph_objects.Figure</code>","text":"<p>Analyze property distributions with histograms and box plots.</p> <p>Parameters:</p> <ul> <li><code>df</code> (pd.DataFrame): Molecular DataFrame</li> <li><code>properties</code> (List[str]): List of property names to analyze</li> <li><code>**kwargs</code>: Additional plotting options</li> </ul> <p>Returns: Multi-subplot figure with distribution plots</p>"},{"location":"tutorials/api-reference/#create_molecular_dashboarddf-pddataframe-plotlygraph_objectsfigure","title":"<code>create_molecular_dashboard(df: pd.DataFrame) -&gt; plotly.graph_objects.Figure</code>","text":"<p>Generate comprehensive molecular analysis dashboard.</p> <p>Features:</p> <ul> <li>Property scatter plots</li> <li>Distribution histograms</li> <li>Statistical summaries</li> <li>Interactive filtering capabilities</li> </ul> <p>Parameters:</p> <ul> <li><code>df</code> (pd.DataFrame): Molecular DataFrame</li> </ul> <p>Returns: Plotly Figure object with multiple subplots</p> <p>Example:</p> <pre><code># Analyze diverse molecule set\nsmiles = [\n    \"CCO\", \"CCC\", \"CCCC\",                    # alkanes\n    \"c1ccccc1\", \"c1ccc2ccccc2c1\",            # aromatics\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",         # caffeine\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\"               # aspirin\n]\n\ndf = create_molecular_dataframe(smiles)\ndashboard = create_molecular_dashboard(df)\ndashboard.show()\n</code></pre>"},{"location":"tutorials/api-reference/#network-visualization","title":"Network Visualization","text":""},{"location":"tutorials/api-reference/#plot_molecular_networkmol-mol-kwargs-plotlygraph_objectsfigure","title":"<code>plot_molecular_network(mol: Mol, **kwargs) -&gt; plotly.graph_objects.Figure</code>","text":"<p>Visualize molecular graph structure as an interactive network.</p> <p>Features:</p> <ul> <li>Nodes represent atoms (colored by element)</li> <li>Edges represent bonds (sized by bond order)</li> <li>Interactive layout with hover information</li> <li>Force-directed positioning</li> </ul> <p>Parameters:</p> <ul> <li><code>mol</code> (Mol): RDKit molecule object</li> <li><code>**kwargs</code>: Additional plotting options</li> </ul> <p>Returns: Plotly Figure object</p> <p>Example:</p> <pre><code>mol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\nfig = plot_molecular_network(mol)\nfig.show()\n</code></pre>"},{"location":"tutorials/api-reference/#error-handling","title":"Error Handling","text":"<p>All functions include comprehensive error handling:</p> <ul> <li>Invalid SMILES: Functions return None or raise ValueError with descriptive messages</li> <li>Empty molecules: Gracefully handled with appropriate warnings</li> <li>Feature extraction errors: Fallback to default values where possible</li> <li>Visualization errors: Return empty figures with error messages</li> </ul>"},{"location":"tutorials/api-reference/#type-hints","title":"Type Hints","text":"<p>All functions include complete type annotations for better IDE support and code clarity.</p>"},{"location":"tutorials/api-reference/#performance-notes","title":"Performance Notes","text":"<ul> <li>Batch processing: Use <code>create_molecular_dataframe()</code> for multiple molecules</li> <li>Large molecules: Set appropriate limits in <code>MoleculeConfig</code></li> <li>Memory usage: 3D conformer generation can be memory-intensive for large molecules</li> <li>Visualization: Interactive plots may be slow for very large datasets</li> </ul>"},{"location":"tutorials/data_processing/","title":"Data Processing Tutorial","text":"<p>This tutorial covers molecular data processing capabilities in Quantifyr, from basic SMILES parsing to advanced batch analysis.</p>"},{"location":"tutorials/data_processing/#basic-smiles-parsing","title":"Basic SMILES Parsing","text":""},{"location":"tutorials/data_processing/#simple-parsing","title":"Simple Parsing","text":"<pre><code>from data_utils import parse_smiles\n\n# Parse basic molecules\nethanol = parse_smiles(\"CCO\")\nbenzene = parse_smiles(\"c1ccccc1\")\ncaffeine = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\n\nprint(f\"Ethanol atoms: {ethanol.GetNumAtoms()}\")\nprint(f\"Benzene atoms: {benzene.GetNumAtoms()}\")\nprint(f\"Caffeine atoms: {caffeine.GetNumAtoms()}\")\n</code></pre>"},{"location":"tutorials/data_processing/#configuration-options","title":"Configuration Options","text":"<pre><code>from data_utils import parse_smiles, MoleculeConfig\n\n# Custom configuration\nconfig = MoleculeConfig(\n    add_hydrogens=True,    # Add explicit hydrogens\n    sanitize=True,         # Sanitize molecules\n    max_atoms=100         # Limit molecule size\n)\n\nmol = parse_smiles(\"CCO\", config)\nprint(f\"With hydrogens: {mol.GetNumAtoms()} atoms\")\n</code></pre>"},{"location":"tutorials/data_processing/#error-handling","title":"Error Handling","text":"<pre><code># Invalid SMILES handling\ntry:\n    invalid_mol = parse_smiles(\"INVALID_SMILES\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Check if molecule is valid\nmol = parse_smiles(\"CCO\")\nif mol is not None:\n    print(\"Valid molecule\")\n</code></pre>"},{"location":"tutorials/data_processing/#feature-extraction","title":"Feature Extraction","text":""},{"location":"tutorials/data_processing/#atomic-features","title":"Atomic Features","text":"<pre><code>from data_utils import parse_smiles, extract_atom_features\n\nmol = parse_smiles(\"CCO\")\natom_features = extract_atom_features(mol)\n\nprint(f\"Number of atoms: {len(atom_features)}\")\nprint(f\"Features per atom: {len(atom_features[0])}\")\nprint(f\"First atom features: {atom_features[0]}\")\n</code></pre> <p>Feature meanings:</p> <ul> <li>Index 0: Atomic number</li> <li>Index 1: Degree (number of bonds)</li> <li>Index 2: Formal charge</li> <li>Index 3: Hybridization (1=SP, 2=SP2, 3=SP3, etc.)</li> <li>Index 4: Aromaticity (0 or 1)</li> <li>Index 5: Number of implicit hydrogens</li> </ul>"},{"location":"tutorials/data_processing/#bond-features","title":"Bond Features","text":"<pre><code>from data_utils import extract_bond_features\n\nmol = parse_smiles(\"c1ccccc1\")  # benzene\nbond_features = extract_bond_features(mol)\n\nprint(f\"Number of bonds: {len(bond_features)}\")\nprint(f\"Features per bond: {len(bond_features[0])}\")\nprint(f\"First bond features: {bond_features[0]}\")\n</code></pre> <p>Feature meanings:</p> <ul> <li>Index 0: Bond type (1=single, 2=double, 3=triple, 1.5=aromatic)</li> <li>Index 1: Conjugation (0 or 1)</li> <li>Index 2: Ring membership (0 or 1)</li> </ul>"},{"location":"tutorials/data_processing/#graph-construction","title":"Graph Construction","text":""},{"location":"tutorials/data_processing/#basic-graph-creation","title":"Basic Graph Creation","text":"<pre><code>from data_utils import parse_smiles, mol_to_graph\n\nmol = parse_smiles(\"CCO\")\ngraph = mol_to_graph(mol)\n\nprint(f\"Graph nodes: {graph.num_nodes}\")\nprint(f\"Graph edges: {graph.num_edges}\")\nprint(f\"Node features shape: {graph.x.shape}\")\nprint(f\"Edge features shape: {graph.edge_attr.shape}\")\nprint(f\"Edge connectivity shape: {graph.edge_index.shape}\")\n</code></pre>"},{"location":"tutorials/data_processing/#graph-without-features","title":"Graph Without Features","text":"<pre><code># Create graph without features (topology only)\ngraph_no_features = mol_to_graph(mol, include_features=False)\nprint(f\"Has node features: {hasattr(graph_no_features, 'x')}\")\nprint(f\"Has edge features: {hasattr(graph_no_features, 'edge_attr')}\")\n</code></pre>"},{"location":"tutorials/data_processing/#understanding-edge-index","title":"Understanding Edge Index","text":"<pre><code>import torch\n\nmol = parse_smiles(\"CCO\")\ngraph = mol_to_graph(mol)\n\n# Edge index is in COO format: [2, num_edges]\nedge_index = graph.edge_index\nprint(f\"Edge index shape: {edge_index.shape}\")\nprint(f\"Edge connections:\\n{edge_index}\")\n\n# Each column represents an edge: [source_node, target_node]\nfor i in range(edge_index.shape[1]):\n    src, dst = edge_index[:, i]\n    print(f\"Edge {i}: atom {src} -&gt; atom {dst}\")\n</code></pre>"},{"location":"tutorials/data_processing/#property-calculation","title":"Property Calculation","text":""},{"location":"tutorials/data_processing/#individual-properties","title":"Individual Properties","text":"<pre><code>from data_utils import parse_smiles, compute_molecular_descriptors\n\nmolecules = {\n    \"ethanol\": \"CCO\",\n    \"benzene\": \"c1ccccc1\", \n    \"caffeine\": \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",\n    \"aspirin\": \"CC(=O)OC1=CC=CC=C1C(=O)O\"\n}\n\nfor name, smiles in molecules.items():\n    mol = parse_smiles(smiles)\n    props = compute_molecular_descriptors(mol)\n\n    print(f\"\\n{name.upper()}:\")\n    print(f\"  Molecular Weight: {props['MW']:.2f} Da\")\n    print(f\"  LogP: {props['LogP']:.2f}\")\n    print(f\"  TPSA: {props['TPSA']:.2f} \u0172\")\n    print(f\"  Rotatable Bonds: {props['NumRotatableBonds']}\")\n    print(f\"  H-Bond Donors: {props['NumHBD']}\")\n    print(f\"  H-Bond Acceptors: {props['NumHBA']}\")\n</code></pre>"},{"location":"tutorials/data_processing/#property-interpretation","title":"Property Interpretation","text":"<ul> <li>MW (Molecular Weight): Mass in Daltons</li> <li>LogP: Lipophilicity (higher = more lipophilic)</li> <li>TPSA: Polar surface area (affects permeability)</li> <li>Rotatable Bonds: Flexibility indicator</li> <li>HBD/HBA: Hydrogen bonding capacity</li> </ul>"},{"location":"tutorials/data_processing/#batch-processing","title":"Batch Processing","text":""},{"location":"tutorials/data_processing/#loading-multiple-molecules","title":"Loading Multiple Molecules","text":"<pre><code>from data_utils import load_molecule_dataset\n\nsmiles_list = [\n    \"CCO\",           # ethanol\n    \"c1ccccc1\",      # benzene\n    \"INVALID\",       # invalid SMILES\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"  # caffeine\n]\n\nmolecules = load_molecule_dataset(smiles_list)\nprint(f\"Loaded {len([m for m in molecules if m is not None])}/{len(molecules)} valid molecules\")\n\n# Process valid molecules\nfor i, mol in enumerate(molecules):\n    if mol is not None:\n        print(f\"Molecule {i}: {mol.GetNumAtoms()} atoms\")\n    else:\n        print(f\"Molecule {i}: Invalid\")\n</code></pre>"},{"location":"tutorials/data_processing/#creating-analysis-dataframes","title":"Creating Analysis DataFrames","text":"<pre><code>from data_utils import create_molecular_dataframe\nimport pandas as pd\n\n# Diverse molecule set\nsmiles_list = [\n    \"CCO\",                                    # ethanol\n    \"CCC\",                                    # propane\n    \"c1ccccc1\",                              # benzene\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",         # caffeine\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\",              # aspirin\n    \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\",        # ibuprofen\n    \"INVALID_SMILES\"                          # invalid\n]\n\ndf = create_molecular_dataframe(smiles_list)\n\n# Display results\nprint(\"Molecular Analysis Results:\")\nprint(df.to_string(index=False))\n\n# Filter valid molecules\nvalid_df = df[df['Valid']].copy()\nprint(f\"\\nValid molecules: {len(valid_df)}/{len(df)}\")\n\n# Statistical summary\nprint(\"\\nProperty Statistics:\")\nnumeric_cols = ['MW', 'LogP', 'TPSA', 'NumRotatableBonds', 'NumHBD', 'NumHBA', 'NumRings']\nprint(valid_df[numeric_cols].describe())\n</code></pre>"},{"location":"tutorials/data_processing/#advanced-filtering","title":"Advanced Filtering","text":"<pre><code># Filter by properties\ndrug_like = valid_df[\n    (valid_df['MW'] &lt;= 500) &amp;           # Lipinski's rule\n    (valid_df['LogP'] &lt;= 5) &amp;           # Lipophilicity\n    (valid_df['NumHBD'] &lt;= 5) &amp;         # H-bond donors\n    (valid_df['NumHBA'] &lt;= 10)          # H-bond acceptors\n]\n\nprint(f\"Drug-like molecules: {len(drug_like)}/{len(valid_df)}\")\nprint(drug_like[['SMILES', 'MW', 'LogP', 'NumHBD', 'NumHBA']])\n</code></pre>"},{"location":"tutorials/data_processing/#working-with-large-datasets","title":"Working with Large Datasets","text":""},{"location":"tutorials/data_processing/#memory-efficient-processing","title":"Memory-Efficient Processing","text":"<pre><code>def process_large_dataset(smiles_list, batch_size=1000):\n    \"\"\"Process large SMILES datasets in batches.\"\"\"\n    results = []\n\n    for i in range(0, len(smiles_list), batch_size):\n        batch = smiles_list[i:i+batch_size]\n        batch_df = create_molecular_dataframe(batch)\n        results.append(batch_df)\n        print(f\"Processed batch {i//batch_size + 1}: {len(batch)} molecules\")\n\n    return pd.concat(results, ignore_index=True)\n\n# Example with simulated large dataset\nlarge_smiles = [\"CCO\", \"c1ccccc1\", \"CCC\"] * 100  # 300 molecules\nresult_df = process_large_dataset(large_smiles, batch_size=50)\nprint(f\"Total processed: {len(result_df)} molecules\")\n</code></pre>"},{"location":"tutorials/data_processing/#parallel-processing","title":"Parallel Processing","text":"<pre><code>from concurrent.futures import ProcessPoolExecutor\nimport multiprocessing as mp\n\ndef process_smiles_chunk(smiles_chunk):\n    \"\"\"Process a chunk of SMILES strings.\"\"\"\n    return create_molecular_dataframe(smiles_chunk)\n\ndef parallel_processing(smiles_list, n_workers=None):\n    \"\"\"Process SMILES list using multiple processes.\"\"\"\n    if n_workers is None:\n        n_workers = mp.cpu_count()\n\n    # Split into chunks\n    chunk_size = len(smiles_list) // n_workers\n    chunks = [smiles_list[i:i+chunk_size] for i in range(0, len(smiles_list), chunk_size)]\n\n    # Process in parallel\n    with ProcessPoolExecutor(max_workers=n_workers) as executor:\n        results = list(executor.map(process_smiles_chunk, chunks))\n\n    return pd.concat(results, ignore_index=True)\n\n# Example usage (commented out to avoid multiprocessing issues in docs)\n# result_df = parallel_processing(large_smiles, n_workers=4)\n</code></pre>"},{"location":"tutorials/data_processing/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/data_processing/#using-error-handling","title":"Using Error Handling","text":"<pre><code>def safe_molecular_processing(smiles_list):\n    \"\"\"Safely process molecules with comprehensive error handling.\"\"\"\n    results = []\n\n    for i, smiles in enumerate(smiles_list):\n        try:\n            mol = parse_smiles(smiles)\n            if mol is not None:\n                props = compute_molecular_descriptors(mol)\n                graph = mol_to_graph(mol)\n\n                results.append({\n                    'index': i,\n                    'smiles': smiles,\n                    'valid': True,\n                    'atoms': mol.GetNumAtoms(),\n                    'bonds': mol.GetNumBonds(),\n                    'graph_nodes': graph.num_nodes,\n                    'graph_edges': graph.num_edges,\n                    **props\n                })\n            else:\n                results.append({\n                    'index': i,\n                    'smiles': smiles,\n                    'valid': False,\n                    'error': 'Invalid molecule'\n                })\n\n        except Exception as e:\n            results.append({\n                'index': i,\n                'smiles': smiles,\n                'valid': False,\n                'error': str(e)\n            })\n\n    return pd.DataFrame(results)\n\n# Test with mixed valid/invalid SMILES\ntest_smiles = [\"CCO\", \"INVALID\", \"c1ccccc1\", \"\"]\nresult_df = safe_molecular_processing(test_smiles)\nprint(result_df)\n</code></pre>"},{"location":"tutorials/data_processing/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use batch processing for multiple molecules</li> <li>Cache results for repeated calculations</li> <li>Set molecule size limits to avoid memory issues</li> <li>Use parallel processing for large datasets</li> <li>Validate SMILES before expensive operations</li> </ol>"},{"location":"tutorials/data_processing/#memory-management","title":"Memory Management","text":"<pre><code>import gc\n\ndef memory_efficient_processing(smiles_list):\n    \"\"\"Process molecules with explicit memory management.\"\"\"\n    results = []\n\n    for i, smiles in enumerate(smiles_list):\n        mol = parse_smiles(smiles)\n        if mol is not None:\n            # Process immediately and store only results\n            props = compute_molecular_descriptors(mol)\n            results.append(props)\n\n            # Clear molecule from memory\n            del mol\n\n            # Periodic garbage collection\n            if i % 100 == 0:\n                gc.collect()\n\n    return results\n</code></pre> <p>This tutorial covers the core data processing capabilities. Next, explore the Visualization Tutorial to learn about creating molecular visualizations.</p>"},{"location":"tutorials/visualization/","title":"Visualization Tutorial","text":"<p>This tutorial covers all molecular visualization capabilities in Quantifyr, from basic 2D structures to interactive dashboards.</p>"},{"location":"tutorials/visualization/#2d-molecular-structures","title":"2D Molecular Structures","text":""},{"location":"tutorials/visualization/#basic-2d-drawing","title":"Basic 2D Drawing","text":"<pre><code>from data_utils import parse_smiles\nfrom viz import draw_molecule_2d\n\n# Parse molecules\ncaffeine = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\naspirin = parse_smiles(\"CC(=O)OC1=CC=CC=C1C(=O)O\")\n\n# Create 2D images\ncaffeine_img = draw_molecule_2d(caffeine)\naspirin_img = draw_molecule_2d(aspirin, width=400, height=300)\n\n# Display images\ncaffeine_img.show()\naspirin_img.show()\n\n# Save images\ncaffeine_img.save(\"caffeine_2d.png\")\naspirin_img.save(\"aspirin_2d.png\")\n</code></pre>"},{"location":"tutorials/visualization/#custom-2d-drawing-options","title":"Custom 2D Drawing Options","text":"<pre><code># High-resolution image\nhigh_res_img = draw_molecule_2d(\n    caffeine, \n    width=800, \n    height=600,\n    kekulize=True,  # Show explicit double bonds\n    wedgeBonds=True  # Show stereochemistry\n)\n\n# Multiple molecules in a grid\nmolecules = [\n    (\"Ethanol\", parse_smiles(\"CCO\")),\n    (\"Benzene\", parse_smiles(\"c1ccccc1\")),\n    (\"Caffeine\", parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")),\n    (\"Aspirin\", parse_smiles(\"CC(=O)OC1=CC=CC=C1C(=O)O\"))\n]\n\nfor name, mol in molecules:\n    img = draw_molecule_2d(mol, width=300, height=200)\n    img.save(f\"{name.lower()}_2d.png\")\n    print(f\"Saved {name} structure\")\n</code></pre>"},{"location":"tutorials/visualization/#3d-interactive-visualizations","title":"3D Interactive Visualizations","text":""},{"location":"tutorials/visualization/#basic-3d-conformers","title":"Basic 3D Conformers","text":"<pre><code>from viz import create_3d_conformer_plot\n\n# Create 3D visualization\nmol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\nfig = create_3d_conformer_plot(mol)\n\n# Display in browser\nfig.show()\n\n# Save as HTML\nfig.write_html(\"caffeine_3d.html\")\n\n# Save as static image\nfig.write_image(\"caffeine_3d.png\", width=800, height=600)\n</code></pre>"},{"location":"tutorials/visualization/#advanced-3d-options","title":"Advanced 3D Options","text":"<pre><code># Custom styling\nfig = create_3d_conformer_plot(\n    mol,\n    atom_size=8,\n    bond_width=4,\n    show_atom_labels=True,\n    background_color='white'\n)\n\n# Update layout\nfig.update_layout(\n    title=\"Caffeine 3D Structure\",\n    scene=dict(\n        xaxis_title=\"X (\u00c5)\",\n        yaxis_title=\"Y (\u00c5)\", \n        zaxis_title=\"Z (\u00c5)\",\n        camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))\n    )\n)\n\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#multiple-3d-conformers","title":"Multiple 3D Conformers","text":"<pre><code>import plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nmolecules = {\n    \"Ethanol\": \"CCO\",\n    \"Benzene\": \"c1ccccc1\",\n    \"Caffeine\": \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"\n}\n\n# Create subplot figure\nfig = make_subplots(\n    rows=1, cols=3,\n    specs=[[{\"type\": \"scatter3d\"}, {\"type\": \"scatter3d\"}, {\"type\": \"scatter3d\"}]],\n    subplot_titles=list(molecules.keys())\n)\n\nfor i, (name, smiles) in enumerate(molecules.items(), 1):\n    mol = parse_smiles(smiles)\n    mol_fig = create_3d_conformer_plot(mol)\n\n    # Add traces to subplot\n    for trace in mol_fig.data:\n        fig.add_trace(trace, row=1, col=i)\n\nfig.update_layout(title=\"Molecular 3D Structures Comparison\")\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#property-analysis-visualizations","title":"Property Analysis Visualizations","text":""},{"location":"tutorials/visualization/#scatter-matrix-plots","title":"Scatter Matrix Plots","text":"<pre><code>from data_utils import create_molecular_dataframe\nfrom viz import plot_molecular_properties\n\n# Create dataset\nsmiles_list = [\n    \"CCO\",                                    # ethanol\n    \"CCC\",                                    # propane\n    \"CCCC\",                                   # butane\n    \"c1ccccc1\",                              # benzene\n    \"c1ccc2ccccc2c1\",                        # naphthalene\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",         # caffeine\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\",              # aspirin\n    \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\"         # ibuprofen\n]\n\ndf = create_molecular_dataframe(smiles_list)\nvalid_df = df[df['Valid']].copy()\n\n# Create scatter matrix\nfig = plot_molecular_properties(valid_df)\nfig.show()\n\n# Save interactive plot\nfig.write_html(\"molecular_properties_scatter.html\")\n</code></pre>"},{"location":"tutorials/visualization/#property-distribution-analysis","title":"Property Distribution Analysis","text":"<pre><code>from viz import plot_property_distribution\n\n# Analyze specific properties\nproperties = ['MW', 'LogP', 'TPSA', 'NumRotatableBonds']\nfig = plot_property_distribution(valid_df, properties)\nfig.show()\n\n# Custom distribution plot\nfig = plot_property_distribution(\n    valid_df, \n    properties=['MW', 'LogP'],\n    plot_type='histogram',  # or 'box'\n    bins=20\n)\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#comprehensive-dashboard","title":"Comprehensive Dashboard","text":"<pre><code>from viz import create_molecular_dashboard\n\n# Create comprehensive analysis dashboard\ndashboard = create_molecular_dashboard(valid_df)\ndashboard.show()\n\n# Save dashboard\ndashboard.write_html(\"molecular_dashboard.html\")\n</code></pre>"},{"location":"tutorials/visualization/#network-visualizations","title":"Network Visualizations","text":""},{"location":"tutorials/visualization/#molecular-graph-networks","title":"Molecular Graph Networks","text":"<pre><code>from viz import plot_molecular_network\n\n# Visualize molecular topology\nmolecules = [\n    (\"Ethanol\", \"CCO\"),\n    (\"Benzene\", \"c1ccccc1\"),\n    (\"Caffeine\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\n]\n\nfor name, smiles in molecules:\n    mol = parse_smiles(smiles)\n    fig = plot_molecular_network(mol)\n    fig.update_layout(title=f\"{name} - Molecular Network\")\n    fig.show()\n    fig.write_html(f\"{name.lower()}_network.html\")\n</code></pre>"},{"location":"tutorials/visualization/#custom-network-styling","title":"Custom Network Styling","text":"<pre><code># Advanced network visualization\nmol = parse_smiles(\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\")\nfig = plot_molecular_network(\n    mol,\n    node_size=15,\n    edge_width=3,\n    layout='spring',  # or 'circular', 'random'\n    show_atom_labels=True,\n    color_by_element=True\n)\n\nfig.update_layout(\n    title=\"Caffeine Molecular Network\",\n    showlegend=True,\n    width=800,\n    height=600\n)\n\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#advanced-visualization-techniques","title":"Advanced Visualization Techniques","text":""},{"location":"tutorials/visualization/#property-correlation-heatmaps","title":"Property Correlation Heatmaps","text":"<pre><code>import plotly.express as px\nimport pandas as pd\n\n# Calculate correlation matrix\nnumeric_cols = ['MW', 'LogP', 'TPSA', 'NumRotatableBonds', 'NumHBD', 'NumHBA', 'NumRings']\ncorr_matrix = valid_df[numeric_cols].corr()\n\n# Create heatmap\nfig = px.imshow(\n    corr_matrix,\n    text_auto=True,\n    aspect=\"auto\",\n    title=\"Molecular Property Correlations\"\n)\n\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#3d-property-space","title":"3D Property Space","text":"<pre><code>import plotly.express as px\n\n# 3D scatter plot in property space\nfig = px.scatter_3d(\n    valid_df,\n    x='MW',\n    y='LogP', \n    z='TPSA',\n    hover_data=['SMILES'],\n    title=\"Molecules in 3D Property Space\",\n    labels={\n        'MW': 'Molecular Weight (Da)',\n        'LogP': 'Lipophilicity',\n        'TPSA': 'Polar Surface Area (\u0172)'\n    }\n)\n\nfig.show()\n</code></pre>"},{"location":"tutorials/visualization/#interactive-property-explorer","title":"Interactive Property Explorer","text":"<pre><code>import plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndef create_property_explorer(df):\n    \"\"\"Create interactive property exploration dashboard.\"\"\"\n\n    # Create subplots\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=[\n            \"MW vs LogP\",\n            \"TPSA Distribution\", \n            \"Rotatable Bonds\",\n            \"H-Bond Capacity\"\n        ],\n        specs=[\n            [{\"type\": \"scatter\"}, {\"type\": \"histogram\"}],\n            [{\"type\": \"bar\"}, {\"type\": \"scatter\"}]\n        ]\n    )\n\n    # MW vs LogP scatter\n    fig.add_trace(\n        go.Scatter(\n            x=df['MW'],\n            y=df['LogP'],\n            mode='markers',\n            text=df['SMILES'],\n            name='Molecules',\n            marker=dict(size=8, opacity=0.7)\n        ),\n        row=1, col=1\n    )\n\n    # TPSA histogram\n    fig.add_trace(\n        go.Histogram(\n            x=df['TPSA'],\n            name='TPSA',\n            nbinsx=10\n        ),\n        row=1, col=2\n    )\n\n    # Rotatable bonds bar chart\n    rot_bonds_counts = df['NumRotatableBonds'].value_counts().sort_index()\n    fig.add_trace(\n        go.Bar(\n            x=rot_bonds_counts.index,\n            y=rot_bonds_counts.values,\n            name='Rotatable Bonds'\n        ),\n        row=2, col=1\n    )\n\n    # H-bond donors vs acceptors\n    fig.add_trace(\n        go.Scatter(\n            x=df['NumHBD'],\n            y=df['NumHBA'],\n            mode='markers',\n            text=df['SMILES'],\n            name='H-Bonds',\n            marker=dict(size=8, opacity=0.7)\n        ),\n        row=2, col=2\n    )\n\n    fig.update_layout(\n        title=\"Interactive Molecular Property Explorer\",\n        height=800,\n        showlegend=False\n    )\n\n    return fig\n\n# Create and display explorer\nexplorer = create_property_explorer(valid_df)\nexplorer.show()\n</code></pre>"},{"location":"tutorials/visualization/#batch-visualization","title":"Batch Visualization","text":""},{"location":"tutorials/visualization/#multiple-molecule-grid","title":"Multiple Molecule Grid","text":"<pre><code>from PIL import Image\nimport math\n\ndef create_molecule_grid(smiles_list, grid_cols=3, img_size=200):\n    \"\"\"Create grid of 2D molecular structures.\"\"\"\n\n    molecules = []\n    for smiles in smiles_list:\n        try:\n            mol = parse_smiles(smiles)\n            if mol is not None:\n                img = draw_molecule_2d(mol, width=img_size, height=img_size)\n                molecules.append((smiles, img))\n        except:\n            continue\n\n    if not molecules:\n        return None\n\n    # Calculate grid dimensions\n    grid_rows = math.ceil(len(molecules) / grid_cols)\n\n    # Create combined image\n    grid_width = grid_cols * img_size\n    grid_height = grid_rows * img_size\n    grid_img = Image.new('RGB', (grid_width, grid_height), 'white')\n\n    # Paste individual images\n    for i, (smiles, img) in enumerate(molecules):\n        row = i // grid_cols\n        col = i % grid_cols\n        x = col * img_size\n        y = row * img_size\n        grid_img.paste(img, (x, y))\n\n    return grid_img\n\n# Create molecule grid\ntest_smiles = [\n    \"CCO\", \"CCC\", \"c1ccccc1\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\", \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\"\n]\n\ngrid = create_molecule_grid(test_smiles, grid_cols=3)\nif grid:\n    grid.save(\"molecule_grid.png\")\n    grid.show()\n</code></pre>"},{"location":"tutorials/visualization/#animated-property-evolution","title":"Animated Property Evolution","text":"<pre><code>import plotly.express as px\n\ndef create_property_animation(df, x_prop='MW', y_prop='LogP', animation_frame='NumRings'):\n    \"\"\"Create animated scatter plot showing property relationships.\"\"\"\n\n    fig = px.scatter(\n        df,\n        x=x_prop,\n        y=y_prop,\n        animation_frame=animation_frame,\n        hover_data=['SMILES'],\n        title=f\"{y_prop} vs {x_prop} by {animation_frame}\",\n        range_x=[df[x_prop].min()*0.9, df[x_prop].max()*1.1],\n        range_y=[df[y_prop].min()*0.9, df[y_prop].max()*1.1]\n    )\n\n    return fig\n\n# Create animated visualization\nif len(valid_df) &gt; 5:  # Only if we have enough data\n    anim_fig = create_property_animation(valid_df)\n    anim_fig.show()\n</code></pre>"},{"location":"tutorials/visualization/#export-and-sharing","title":"Export and Sharing","text":""},{"location":"tutorials/visualization/#high-quality-static-images","title":"High-Quality Static Images","text":"<pre><code># Export high-resolution images\nmolecules = [\"CCO\", \"c1ccccc1\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]\n\nfor i, smiles in enumerate(molecules):\n    mol = parse_smiles(smiles)\n\n    # 2D high-res\n    img_2d = draw_molecule_2d(mol, width=800, height=600)\n    img_2d.save(f\"molecule_{i}_2d_hires.png\")\n\n    # 3D static\n    fig_3d = create_3d_conformer_plot(mol)\n    fig_3d.write_image(f\"molecule_{i}_3d_static.png\", width=800, height=600)\n</code></pre>"},{"location":"tutorials/visualization/#interactive-html-reports","title":"Interactive HTML Reports","text":"<pre><code>def create_molecular_report(smiles_list, output_file=\"molecular_report.html\"):\n    \"\"\"Create comprehensive HTML report with all visualizations.\"\"\"\n\n    # Process molecules\n    df = create_molecular_dataframe(smiles_list)\n    valid_df = df[df['Valid']].copy()\n\n    # Create visualizations\n    dashboard = create_molecular_dashboard(valid_df)\n    properties_plot = plot_molecular_properties(valid_df)\n\n    # Combine into report\n    html_content = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Molecular Analysis Report&lt;/title&gt;\n        &lt;style&gt;\n            body {{ font-family: Arial, sans-serif; margin: 20px; }}\n            .section {{ margin: 30px 0; }}\n            .plot {{ margin: 20px 0; }}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Molecular Analysis Report&lt;/h1&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h2&gt;Dataset Summary&lt;/h2&gt;\n            &lt;p&gt;Total molecules: {len(df)}&lt;/p&gt;\n            &lt;p&gt;Valid molecules: {len(valid_df)}&lt;/p&gt;\n            &lt;p&gt;Success rate: {len(valid_df)/len(df)*100:.1f}%&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h2&gt;Comprehensive Dashboard&lt;/h2&gt;\n            &lt;div class=\"plot\"&gt;{dashboard.to_html(include_plotlyjs='cdn')}&lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"section\"&gt;\n            &lt;h2&gt;Property Correlations&lt;/h2&gt;\n            &lt;div class=\"plot\"&gt;{properties_plot.to_html(include_plotlyjs='cdn')}&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    with open(output_file, 'w') as f:\n        f.write(html_content)\n\n    print(f\"Report saved to {output_file}\")\n\n# Generate report\nreport_smiles = [\n    \"CCO\", \"CCC\", \"c1ccccc1\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\",\n    \"CC(=O)OC1=CC=CC=C1C(=O)O\", \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\"\n]\n\ncreate_molecular_report(report_smiles)\n</code></pre>"},{"location":"tutorials/visualization/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/visualization/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Use appropriate image sizes - Don't create unnecessarily large images</li> <li>Batch processing - Process multiple molecules together</li> <li>Cache results - Save generated visualizations for reuse</li> <li>Memory management - Clear large objects when done</li> </ol>"},{"location":"tutorials/visualization/#visual-design","title":"Visual Design","text":"<ol> <li>Consistent styling - Use consistent colors and sizes</li> <li>Clear labels - Always label axes and provide titles</li> <li>Interactive elements - Use hover information effectively</li> <li>Color accessibility - Consider colorblind-friendly palettes</li> </ol>"},{"location":"tutorials/visualization/#file-management","title":"File Management","text":"<pre><code>import os\nfrom pathlib import Path\n\n# Organize output files\noutput_dir = Path(\"molecular_visualizations\")\noutput_dir.mkdir(exist_ok=True)\n\n# Create subdirectories\n(output_dir / \"2d_structures\").mkdir(exist_ok=True)\n(output_dir / \"3d_conformers\").mkdir(exist_ok=True)\n(output_dir / \"property_plots\").mkdir(exist_ok=True)\n(output_dir / \"networks\").mkdir(exist_ok=True)\n\n# Save with organized structure\nmolecules = [\"CCO\", \"c1ccccc1\", \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\"]\n\nfor i, smiles in enumerate(molecules):\n    mol = parse_smiles(smiles)\n    name = f\"molecule_{i}\"\n\n    # 2D structure\n    img_2d = draw_molecule_2d(mol)\n    img_2d.save(output_dir / \"2d_structures\" / f\"{name}.png\")\n\n    # 3D conformer\n    fig_3d = create_3d_conformer_plot(mol)\n    fig_3d.write_html(output_dir / \"3d_conformers\" / f\"{name}.html\")\n\n    # Network\n    fig_net = plot_molecular_network(mol)\n    fig_net.write_html(output_dir / \"networks\" / f\"{name}_network.html\")\n\nprint(f\"All visualizations saved to {output_dir}\")\n</code></pre> <p>This tutorial covers all visualization capabilities. Next, explore the API Reference for detailed function documentation.</p>"}]}